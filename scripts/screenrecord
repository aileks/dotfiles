#!/bin/bash

set -uo pipefail

PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:$PATH"

MODE="${1:-area}"
RECORDING_DIR="$HOME/Videos/recordings"
PIDFILE="/tmp/screenrecord.pid"
FILENAME="recording-$(date +%Y%m%d-%H%M%S).mp4"

notify() {
  local title="$1"
  local message="$2"
  local urgency="${3:-normal}"

  if command -v notify-send >/dev/null 2>&1; then
    notify-send -a screenrecord -u "$urgency" "$title" "$message"
  else
    printf '%s\n' "$title: $message" >&2
  fi
}

require_bin() {
  if ! command -v "$1" >/dev/null 2>&1; then
    notify "Recording error" "Missing dependency: $1"
    exit 1
  fi
}

require_bin wf-recorder
require_bin slurp

get_niri_gap() {
  local gap="${NIRI_GAPS:-}"
  local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/niri/config.kdl"

  if [[ -z ${gap} && -f $config_file ]]; then
    gap=$(awk '/^[[:space:]]*gaps[[:space:]]+/ {print $2; exit}' "$config_file")
  fi

  if [[ ! ${gap:-} =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
    gap=6
  fi

  printf '%s' "$gap"
}

# Check if already recording
if [[ -f $PIDFILE ]]; then
  PID=$(cat "$PIDFILE")
  if kill -0 "$PID" 2>/dev/null; then
    kill -SIGINT "$PID"
    rm -f "$PIDFILE"
    notify "Recording stopped" "Saved to $RECORDING_DIR"
    exit 0
  else
    rm -f "$PIDFILE"
  fi
fi

mkdir -p "$RECORDING_DIR"

select_region() {
  slurp
}

select_window_region() {
  require_bin niri
  require_bin jq

  local windows_json
  local workspaces_json
  local outputs_json
  local gap
  local rects

  if ! windows_json=$(niri msg --json windows 2>/dev/null); then
    notify "Recording error" "Failed to query niri windows" "critical"
    exit 1
  fi

  if ! workspaces_json=$(niri msg --json workspaces 2>/dev/null); then
    notify "Recording error" "Failed to query niri workspaces" "critical"
    exit 1
  fi

  if ! outputs_json=$(niri msg --json outputs 2>/dev/null); then
    notify "Recording error" "Failed to query niri outputs" "critical"
    exit 1
  fi

  gap=$(get_niri_gap)

  rects=$(jq -nr \
    --argjson windows "$windows_json" \
    --argjson workspaces "$workspaces_json" \
    --argjson outputs "$outputs_json" \
    --argjson gap "$gap" \
    '
    def unwrap: (.Ok // .);
    def arrify: (if type == "array" then . else (if type == "object" then (.[]?) else [] end) end);

    def outputs_raw: ($outputs | unwrap | (.outputs // .Outputs // .));
    def workspaces_raw: ($workspaces | unwrap | (.workspaces // .Workspaces // .) | arrify);
    def windows_raw: ($windows | unwrap | (.windows // .Windows // .) | arrify);

    def output_map:
      (outputs_raw
       | if type == "object" then
           to_entries
           | map(select(.value.logical != null) | {key: .key, value: .value.logical})
           | from_entries
         else
           map(select(.logical != null) | {key: (.name // .id // "unknown"), value: .logical})
           | from_entries
         end);

    def workspace_map:
      (workspaces_raw
       | map(select(.output != null) | {key: (.id | tostring), value: .output})
       | from_entries);

    def column_x_map($wins; $gap):
      ($wins
       | map(select(.layout.pos_in_scrolling_layout != null))
       | group_by(.layout.pos_in_scrolling_layout[0])
       | map({col: .[0].layout.pos_in_scrolling_layout[0], width: (map(.layout.tile_size[0]) | max)})
       | sort_by(.col)
       | reduce .[] as $c ({x: $gap, map: {}};
           .map[($c.col | tostring)] = .x
           | .x = (.x + $c.width + $gap)
         )
       | .map);

    def tile_y_map($wins; $gap):
      ($wins
       | map(select(.layout.pos_in_scrolling_layout != null))
       | sort_by(.layout.pos_in_scrolling_layout[0], .layout.pos_in_scrolling_layout[1])
       | group_by(.layout.pos_in_scrolling_layout[0])
       | map({
           col: .[0].layout.pos_in_scrolling_layout[0],
           map: (reduce .[] as $w ({y: $gap, map: {}};
                   .map[($w.id | tostring)] = .y
                   | .y = (.y + $w.layout.tile_size[1] + $gap)
                 ) | .map)
         })
       | reduce .[] as $c ({}; .[($c.col | tostring)] = $c.map));

    def win_pos($w; $col_x; $tile_y):
      (if $w.layout.tile_pos_in_workspace_view != null then
         $w.layout.tile_pos_in_workspace_view
       elif $w.layout.pos_in_scrolling_layout != null then
         ($w.layout.pos_in_scrolling_layout[0] as $col
          | [($col_x[($col | tostring)] // null), ($tile_y[($col | tostring)][($w.id | tostring)] // null)])
       else
         null
       end);

    def win_size:
      (if .layout.tile_size != null then
         .layout.tile_size
       elif .layout.window_size != null then
         .layout.window_size
       else
         null
       end);

    windows_raw
    | map(select(.workspace_id != null))
    | sort_by(.workspace_id)
    | group_by(.workspace_id)
    | map(
        . as $wins
        | (column_x_map($wins; $gap)) as $col_x
        | (tile_y_map($wins; $gap)) as $tile_y
        | $wins
        | map(
            . as $w
            | (workspace_map[($w.workspace_id | tostring)] // null) as $out_name
            | (output_map[$out_name] // null) as $out
            | select($out != null)
            | (win_pos($w; $col_x; $tile_y)) as $p
            | (win_size($w)) as $s
            | select($p != null and $s != null)
            | {
                x: ($out.x + $p[0]),
                y: ($out.y + $p[1]),
                w: ($s[0]),
                h: ($s[1]),
                label: ((($w.app_id // "window") + ":" + ($w.id | tostring)))
              }
          )
      )
    | add
    | map("\(.x|floor|tostring),\(.y|floor|tostring) \(.w|ceil|tostring)x\(.h|ceil|tostring) \(.label)")
    | .[]
    '
  )

  if [[ -z ${rects} ]]; then
    notify "Recording error" "No windows available to select" "critical"
    exit 1
  fi

  printf '%s\n' "$rects" | slurp -r
}

fullscreen_region() {
  require_bin niri
  require_bin jq

  local outputs_json
  local workspaces_json
  local rect

  if ! outputs_json=$(niri msg --json outputs 2>/dev/null); then
    notify "Recording error" "Failed to query niri outputs" "critical"
    exit 1
  fi

  if ! workspaces_json=$(niri msg --json workspaces 2>/dev/null); then
    notify "Recording error" "Failed to query niri workspaces" "critical"
    exit 1
  fi

  rect=$(jq -nr \
    --argjson outputs "$outputs_json" \
    --argjson workspaces "$workspaces_json" \
    '
    def unwrap: (.Ok // .);
    def arrify: (if type == "array" then . else (if type == "object" then (.[]?) else [] end) end);

    def outputs_raw: ($outputs | unwrap | (.outputs // .Outputs // .));
    def workspaces_raw: ($workspaces | unwrap | (.workspaces // .Workspaces // .) | arrify);

    def output_map:
      (outputs_raw
       | if type == "object" then
           to_entries
           | map(select(.value.logical != null) | {key: .key, value: .value.logical})
           | from_entries
         else
           map(select(.logical != null) | {key: (.name // .id // "unknown"), value: .logical})
           | from_entries
         end);

    def focused_output_from_workspace:
      (workspaces_raw
       | map(select(.is_focused == true or .is_focused == 1) | .output)
       | first);

    def union_rect:
      (output_map
       | to_entries
       | map(.value)
       | map(select(. != null)) as $outs
       | if ($outs | length) == 0 then empty else
         $outs
         | {minx: (map(.x) | min), miny: (map(.y) | min),
            maxx: (map(.x + .width) | max), maxy: (map(.y + .height) | max)}
         | {x: (.minx | floor), y: (.miny | floor),
            w: ((.maxx | ceil) - (.minx | floor)),
            h: ((.maxy | ceil) - (.miny | floor))}
       end);

    def focused_rect:
      (focused_output_from_workspace as $name
       | (output_map[$name] // null)
       | if . == null then empty else
         {x: (.x|floor), y: (.y|floor), w: (.width|ceil), h: (.height|ceil)}
         end);

    (focused_rect // union_rect)
    | if . == null then empty else "\(.x),\(.y) \(.w)x\(.h)" end
    '
  )

  printf '%s\n' "$rect"
}

case "$MODE" in
  area)
    region=$(select_region || true)
    if [[ -z ${region} ]]; then
      notify "Recording cancelled" "No region selected"
      exit 1
    fi
    wf-recorder -g "$region" -f "$RECORDING_DIR/$FILENAME" &
    ;;
  window)
    region=$(select_window_region || true)
    if [[ -z ${region} ]]; then
      notify "Recording cancelled" "No window selected"
      exit 1
    fi
    wf-recorder -g "$region" -f "$RECORDING_DIR/$FILENAME" &
    ;;
  fullscreen)
    region=$(fullscreen_region || true)
    if [[ -z ${region} ]]; then
      notify "Recording error" "No fullscreen region found"
      exit 1
    fi
    wf-recorder -g "$region" -f "$RECORDING_DIR/$FILENAME" &
    ;;
  *)
    echo "Usage: screenrecord [area|window|fullscreen]"
    exit 1
    ;;
esac

echo $! >"$PIDFILE"
notify "Recording started" "Mode: $MODE"
